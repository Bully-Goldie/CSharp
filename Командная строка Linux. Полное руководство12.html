<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0046)http://10.207.106.8/os/pr/978549602303-23.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Командная строка Linux. Полное руководство</title>
  <link href="./Командная строка Linux. Полное руководство12_files/template.css" rel="stylesheet" type="text/css">
</head>

<body id="x978549602303" xml:lang="en-US">
  <div class="Basic-Text-Frame">
     <h1 id="toc_marker-23" xml:lang="ru-RU">18. Архивация и резервное копирование</h1>

    <p class="Normal0" xml:lang="ru-RU">Одной из основных задач администратора компьютерных систем является обеспечение безопасности данных, а одним из способов решения этой задачи — свое­временное создание резервных копий системных файлов. Даже если вы не являетесь системным администратором, вам все равно пригодится умение создавать копии и перемещать большие коллекции файлов из одного места в другое и с одного устройства на другое.</p>

    <p xml:lang="ru-RU">В этой главе мы рассмотрим несколько программ, часто используемых для управления коллекциями файлов, в том числе:</p>

    <p xml:lang="ru-RU">Программы сжатия:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• gzip</span> — сжимает и распаковывает файлы.</p>

    <p class="ListBulLast" xml:lang="ru-RU"><span class="command char-style-override-1">• bzip2</span> — программа поблочного сжатия файлов.</p>

    <p xml:lang="ru-RU">Программы архивирования:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• tar</span> — утилита архивирования на ленту.</p>

    <p class="ListBulLast" xml:lang="ru-RU"><span class="command char-style-override-1">• zip</span> — упаковывает и сжимает файлы.</p>

    <p xml:lang="ru-RU">И программа синхронизации файлов:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• rsync</span> — выполняет синхронизацию файлов и каталогов с удаленной системой.</p>

    <h2 id="toc_marker-23-1" xml:lang="ru-RU">Сжатие файлов</h2>

    <p class="Normal0" xml:lang="ru-RU">На протяжении всей истории развития вычислительных технологий не прекращались попытки размещения большего числа данных в меньшем объеме, будь то память, устройства хранения или полоса пропускания сети. Многие устройства и технологии, прочно вошедшие в обиход, такие как переносные плееры, телевидение высокой четкости или широкополосный доступ в Интернет, обязаны своим существованием эффективным технологиям <em>сжатия данных</em>.</p>

    <p xml:lang="ru-RU">Сжатие данных — это процесс устранения <em>избыточных</em> данных. Давайте рассмот­рим воображаемый пример. Допустим, у нас есть файл, хранящий изображение абсолютно черного квадрата размером 100 на 100 пикселей. В терминах хранения данных (если предположить, что каждый пиксель представлен 24 битами, или 3 байтами) изображение занимает 30 000 байт: 100 х 100 х 3 = 30 000.</p>

    <p xml:lang="ru-RU">Изображение, состоящее из пикселей одного цвета, содержит массу избыточных данных. Будь мы умнее, мы могли бы закодировать данные в виде простого описания того факта, что изображение представлено блоком из 30 000 пикселей черного цвета. То есть вместо хранения блока данных с 30 000 нулей (черный цвет в файлах изображений обычно представлен нулевым значением) мы могли бы сжать данные до числа 30 000 с последующим нулем, описывающим цвет. Такая схема сжатия, она называется <em>кодированием длин серий</em> (run-length encoding), является одной из простейших технологий сжатия. Современные технологии не в пример сложнее и эффективнее, но главная цель осталась прежней — избавиться от избыточных данных.</p>

    <p xml:lang="ru-RU"><em>Алгоритмы сжатия</em> (математические методики, применяемые для осуществления сжатия) делятся на две основные категории: <em>без потерь</em> (lossless) и <em>с потерями</em> (lossy). Сжатие без потерь гарантирует сохранность всех данных, содержащихся в оригинале. То есть после восстановления файла из сжатой версии восстановленный файл будет иметь в точности то же содержимое, что и несжатый оригинал. Сжатие с потерями, с другой стороны, удаляет некоторые данные во время сжатия, чтобы обеспечить более высокую степень сжатия. Восстановленный файл в этом случае не будет совпадать с оригинальной версией, скорее он будет близкой аппроксимацией оригинала. Примерами сжатия с потерями могут служить формат JPEG (для изображений) и MP3 (для музыкальных произведений). В дальнейшем обсуждении мы будем рассматривать только сжатие без потерь, поскольку большинство данных в компьютерах потерь не допускает.</p>

    <h3 xml:lang="ru-RU">gzip — сжатие и распаковывание файлов</h3>

    <p class="Normal0" xml:lang="ru-RU">Программа <span class="command char-style-override-1">gzip</span> используется для сжатия одного или нескольких файлов. Во время работы она замещает оригинальный файл его сжатой версией. Соответствующая программа <span class="command char-style-override-1">gunzip</span> используется для восстановления сжатых файлов до исходного состояния. Например:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>ls -l /etc &gt; foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>ls -l foo.*</strong></p>

    <p class="listing-body">-rw-r--r-- 1 me&nbsp;&nbsp;&nbsp;&nbsp;me&nbsp;&nbsp;&nbsp;&nbsp;15738 2012-10-14 07:15 foo.txt</p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>gzip foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>ls -l foo.*</strong></p>

    <p class="listing-body">-rw-r--r-- 1 me&nbsp;&nbsp;&nbsp;&nbsp;me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3230 2012-10-14 07:15 foo.txt.gz</p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>gunzip foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>ls -l foo.*</strong></p>

    <p class="list-last">-rw-r--r-- 1 me&nbsp;&nbsp;&nbsp;&nbsp;me&nbsp;&nbsp;&nbsp;&nbsp;15738 2012-10-14 07:15 foo.txt</p>

    <p xml:lang="ru-RU">В этом примере мы создали текстовый файл с именем <em>foo.txt</em>, записав в него список содержимого каталога <em>/etc</em>. Далее мы запустили программу <span class="command char-style-override-1">gzip</span>, которая заменила оригинальный файл сжатой версией с именем <em>foo.txt.gz</em>. В списке содержимого каталога, который был получен с использованием шаблона <em>foo.*</em>, можно видеть, что исходный файл действительно был замещен сжатой версией, и эта сжатая версия получилась почти в пять раз меньше оригинала. Можно также заметить, что сжатый файл имеет такие же разрешения и время, что и оригинал.</p>

    <p xml:lang="ru-RU">Далее мы запустили программу <span class="command char-style-override-1">gunzip</span>, чтобы распаковать файл. После этого, как видите, сжатая версия была замещена оригиналом, и снова с теми же разрешениями и временем.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">gzip</span> имеет множество параметров, часть которых описана в табл. 18.1.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 18</strong><strong>.1.</strong> Параметры команды gzip</p>

    <table id="table-78" class="Table-Style-1">
      <colgroup>      <col>

      <col>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2 cell-style-override-6">       <p class="Tabl-head" xml:lang="ru-RU">Параметр</p>

</td>

      <td class="Cell-Style-2 cell-style-override-6">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-c</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Выводит результат на стандартный вывод и сохраняет оригинальные файлы. Аналогичный эффект дают параметры <span class="command char-style-override-4">--stdout</span> и <span class="command char-style-override-4">--to-stdout</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-d</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Распаковывает файл. С этим параметром <span class="command char-style-override-4">gzip</span> действует как <span class="command char-style-override-4">gunzip</span>. Аналогичный эффект дают параметры <span class="command char-style-override-4">--decompress</span> и <span class="command char-style-override-4">--uncompress</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-f</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Принудительное (force) сжатие, даже если сжатая версия оригинального файла уже существует. Аналогичный эффект дает параметр <span class="command char-style-override-4">--force</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-h</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Выводит информацию о порядке использования. Аналогичный эффект дает параметр <span class="command char-style-override-4">--help</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-l</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Выводит список статистик для каждого сжатого файла. Аналогичный эффект дает параметр <span class="command char-style-override-4">--list</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-t</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Проверяет целостность сжатого файла. Аналогичный эффект дает параметр <span class="command char-style-override-4">--test</span><span class="command char-style-override-4"></span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-v</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Выводит в процессе работы сообщения с информацией о ходе сжатия. Аналогичный эффект дает параметр <span class="command char-style-override-4">--verbose</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-число</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-6">       <p class="Tabl-body" xml:lang="ru-RU">Устанавливает степень сжатия. Числом может быть любое целочисленное значение в диапазоне от 1 (высокая скорость работы, низкая степень сжатия) до 9 (низкая скорость работы, высокая степень сжатия). Значения 1 и 9 можно также заменить параметрами <span class="command char-style-override-4">--fast</span> и <span class="command char-style-override-4">--best</span> соответственно. По умолчанию используется значение 6</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Вернемся к нашему примеру:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>gzip foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>gzip -tv foo.txt.gz</strong></p>

    <p class="listing-body">foo.txt.gz: OK</p>

    <p class="list-last">[me@linuxbox ~]$ <strong>gzip -d foo.txt.gz</strong></p>

    <p xml:lang="ru-RU">Здесь мы заменили файл <span class="command char-style-override-1">foo.txt</span> его сжатой версией с именем <span class="command char-style-override-1">foo.txt.gz</span>. Затем проверили целостность сжатой версии, передав параметры <span class="command char-style-override-1">-t</span> и <span class="command char-style-override-1">-v</span>. В заключение мы распаковали файл, вернув его исходное состояние.</p>

    <p xml:lang="ru-RU"><span class="command char-style-override-1">gzip</span> можно также использовать несколько необычным способом, через стандартные ввод и вывод:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>ls -l /etc | gzip &gt; foo.txt.gz</strong></p>

    <p xml:lang="ru-RU">Эта команда создает сжатую версию списка с содержимым каталога.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">gunzip</span>, которая распаковывает файлы, сжатые с помощью <span class="command char-style-override-1">gzip</span>, предполагает, что имена файлов оканчиваются расширением <em>.gz</em>, поэтому его можно не указывать при условии, что имя файла в команде не соответствует существующему несжатому файлу:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>gunzip foo.txt</strong></p>

    <p xml:lang="ru-RU">Если цель только в том, чтобы просмотреть содержимое сжатого текстового файла, сделать это можно так:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>gunzip -c foo.txt | less</strong></p>

    <p xml:lang="ru-RU">Вместе с <span class="command char-style-override-1">gzip</span> обычно поставляется программа <span class="command char-style-override-1">zcat</span>, которая действует подобно программе <span class="command char-style-override-1">gunzip</span> с параметром <span class="command char-style-override-1">-c</span>. Она применяется к файлам, сжатым с помощью <span class="command char-style-override-1">gzip</span>, по аналогии с командой <span class="command char-style-override-1">cat</span>:</p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>zcat foo.txt.gz | less</strong></p>

    <p class="Vrezka-head" xml:lang="ru-RU">ПРИМЕЧАНИЕ</p>

    <p class="Vrezka-body" xml:lang="ru-RU">Существует также программа <span class="command char-style-override-1">zless</span>. Она заменяет собой конвейер, представленный выше.</p>

    <h3 xml:lang="ru-RU">bzip2 — высокая степень сжатия ценой скорости</h3>

    <p class="Normal0" xml:lang="ru-RU">Программа <span class="command char-style-override-1">bzip2</span> Джулиана Сюарда похожа на программу <span class="command char-style-override-1">gzip</span>, но использует иной алгоритм, который обеспечивает более высокую степень сжатия ценой снижения скорости работы. Во многих отношениях она действует точно так же, как <span class="command char-style-override-1">gzip</span>. Файл, сжатый с помощью <span class="command char-style-override-1">bzip2</span>, получает расширение <em>.</em><em>bz2</em>:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>ls -l /etc &gt; foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>ls -l foo.txt</strong></p>

    <p class="listing-body">-rw-r--r-- 1 me&nbsp;&nbsp;&nbsp;&nbsp;me&nbsp;&nbsp;&nbsp;&nbsp;15738 2012-10-17 13:51 foo.txt</p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>bzip2 foo.txt</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>ls -l foo.txt.bz2</strong></p>

    <p class="listing-body">-rw-r--r-- 1 me&nbsp;&nbsp;&nbsp;&nbsp;me&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2792 2012-10-17 13:51 foo.txt.bz2</p>

    <p class="list-last">[me@linuxbox ~]$ <strong>bunzip2 foo.txt.bz2</strong></p>

    <p xml:lang="ru-RU">Как видите, <span class="command char-style-override-1">bzip2</span> можно использовать так же, как <span class="command char-style-override-1">gzip</span>. Все параметры программы <span class="command char-style-override-1">gzip</span> (кроме <span class="command char-style-override-1">-r</span>), представленные выше, поддерживаются также программой <span class="command char-style-override-1">bzip2</span>. Но имейте в виду, что параметр степени сжатия (<span class="command char-style-override-1">-число</span>) имеет несколько иной смысл для <span class="command char-style-override-1">bzip2</span>. В паре с <span class="command char-style-override-1">bzip2</span> поставляются программы <span class="command char-style-override-1">bunzip2</span> и <span class="command char-style-override-1">bzcat</span> для распаковывания файлов.</p>

    <p xml:lang="ru-RU">Существует также программа <span class="command char-style-override-1">bzip2recover</span> для восстановления поврежденных файлов формата <em>.bz</em><em>2</em>.</p>

    <p class="Vrezka-head" xml:lang="ru-RU">не превращайтесь в одержимых манией сжатия</p>

    <p class="Vrezka-body" xml:lang="ru-RU">Мне иногда приходится видеть, как кто-то пытается сжать файл, уже сжатый с применением эффективного алгоритма сжатия, выполняя нечто подобное:</p>

    <p class="vrezka-listing"><span class="command char-style-override-7">$ gzip picture.jpg</span></p>

    <p class="Vrezka-body" xml:lang="ru-RU">Это напрасная трата времени и дискового пространства! Если применить процедуру сжатия к уже сжатому файлу, зачастую получается файл большего размера. Это объясняется тем, что все методики сжатия добавляют в файл некоторую служебную информацию, описывающую сжатие. Если попытаться сжать файл, не содержащий избыточной информации, сжатие не приведет к экономии места, которая могла бы покрыть расходы на хранение служебной информации.</p>

    <h2 id="toc_marker-23-2" xml:lang="ru-RU">Архивирование файлов</h2>

    <p class="Normal0" xml:lang="ru-RU">Часто вместе со сжатием используется операция <em>архивирования</em>. Архивирование — это процесс сбора множества файлов и упаковывание их в один большой файл. Архивирование часто применяется как один из этапов создания резервных копий системы. Оно также используется при перемещении старых данных из системы в некоторое долговременное хранилище.</p>

    <h3 xml:lang="ru-RU">tar — утилита архивирования на ленту</h3>

    <p class="Normal0" xml:lang="ru-RU">В мире программного обеспечения для Unix-подобных систем существует программа <span class="command char-style-override-1">tar</span> — классический инструмент для архивирования файлов. Ее имя, которое расшифровывается как <em>tape archive</em> (архив на магнитной ленте), указывает, что первоначально инструмент предназначался для создания архивов на магнитных лентах. Он до сих пор используется для решения этой традиционной задачи, но с неменьшим успехом поддерживает другие устройства хранения. Нам часто приходится видеть имена файлов с расширением <em>.tar</em> или <em>.tgz</em>, которые обозначают «простые» tar-архивы и архивы, сжатые с помощью <span class="command char-style-override-1">gzip</span> соответственно. Архив может состоять из группы отдельных файлов, иерархий каталогов или и того и другого. Команда <span class="command char-style-override-1">tar</span> имеет следующий синтаксис:</p>

    <p class="list-one">tar <em>режим</em>[<em>параметры</em>] <em>путь</em>...</p>

    <p xml:lang="ru-RU">где под <em>режимом</em> подразумевается один из нескольких режимов работы, перечисленных в табл. 18.2 (здесь представлены не все параметры; полный список вы найдете на странице справочного руководства (<span class="command char-style-override-1">man</span>) для <span class="command char-style-override-1">tar</span>).</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 18.2.</strong> Режимы команды tar</p>

    <table id="table-79" class="Table-Style-1">
      <colgroup>      <col>

      <col>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2 cell-style-override-10">       <p class="Tabl-head" xml:lang="ru-RU">Режим</p>

</td>

      <td class="Cell-Style-2 cell-style-override-10">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">c</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU">Создать архив из списка файлов и/или каталогов</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">x</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU">Извлечь файлы из архива</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">r</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU">Добавить указанный файл и/или каталог в конец архива</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">t</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-10">       <p class="Tabl-body" xml:lang="ru-RU">Вывести список содержимого архива</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">В программе <span class="command char-style-override-1">tar</span> используется немного непривычный способ определения параметров, поэтому рассмотрим несколько примеров ее использования. Для начала воссоздадим нашу песочницу, как мы это делали в предыдущей главе:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir -p playground/dir-{00{1..9},0{10..99},100}</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}</strong></p>

    <p xml:lang="ru-RU">Далее создадим архив всей песочницы:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>tar cf playground.tar playground</strong></p>

    <p xml:lang="ru-RU">Эта команда создаст tar-архив с именем <em>playground.tar</em>, включающий всю иерархию каталогов песочницы. Как видите, режим и параметр <span class="command char-style-override-1">f</span>, который используется для определения имени tar-архива, можно объединять, и при этом не требуется использовать начальный дефис. Но имейте в виду, что режим всегда должен указываться первым, перед любыми параметрами. Посмотреть содержимое архива можно с помощью следующей команды:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>tar tf playground.tar</strong></p>

    <p xml:lang="ru-RU">Для получения более подробного списка добавим параметр <span class="command char-style-override-1">v</span> (verbose — подробности):</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>tar tvf playground.tar</strong></p>

    <p xml:lang="ru-RU">Теперь извлечем содержимое архива в другой каталог. Для этого создадим новый каталог с именем <em>foo</em>, перейдем в него и извлечем содержимое tar-архива:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir foo</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>cd foo</strong></p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>tar xf ../playground.tar</strong></p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>ls</strong></p>

    <p class="list-last">playground</p>

    <p xml:lang="ru-RU">Если внимательно исследовать содержимое <em>~/</em><em>foo/playground</em>, можно заметить, что в результате распаковывания архива мы получили точные копии оригинальных файлов. Однако следует помнить, что если вы не действуете от имени суперпользователя, файлы и каталоги, извлеченные из архива, будут принадлежать пользователю, выполнившему восстановление, а не первоначальному их владельцу.</p>

    <p xml:lang="ru-RU">Другой интересной особенностью <span class="command char-style-override-1">tar</span> является способ обработки путей в архивах. По умолчанию используются относительные пути, а не абсолютные. Для этого программа <span class="command char-style-override-1">tar</span> просто удаляет начальный слеш во всех путях. Чтобы показать это, создадим снова наш архив, но на этот раз укажем абсолютный путь к архивируемому каталогу:</p>

    <p class="list-first">[me@linuxbox foo]$ <strong>cd</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>tar cf playground2.tar ~/playground</strong></p>

    <p xml:lang="ru-RU">Как вы помните, командная оболочка заменит <em>~/playground</em> полным путем <em>/home/me</em><em>/playground</em> после нажатия клавиши <span class="interface char-style-override-2">ENTER</span>, благодаря этому мы получим полный путь для нашей демонстрации. Далее извлечем архив, так же как прежде, и посмотрим, что из этого получилось:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>cd foo</strong></p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>tar xf ../playground2.tar</strong></p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>ls</strong></p>

    <p class="listing-body">home playground</p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>ls home</strong></p>

    <p class="listing-body">me</p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>ls home/me</strong></p>

    <p class="list-last">playground</p>

    <p xml:lang="ru-RU">Как видите, здесь при извлечении архива каталог <em>home/</em><em>me/playground</em> был воссоздан не в корневом, а в текущем рабочем каталоге <span class="command char-style-override-1">~/foo</span>, как было бы в случае с абсолютными путями. Это может показаться странным, но такое решение имеет свои преимущества: оно позволяет извлекать архивы в любое другое место, а не только в исходное. Повторив это упражнение с параметром, управляющим выводом дополнительных сообщений (<span class="command char-style-override-1">v</span>), можно получить более понятную картину происходящего.</p>

    <p xml:lang="ru-RU">Рассмотрим пусть и гипотетический, но все же имеющий практическую ценность пример использования <span class="command char-style-override-1">tar</span>. Представим, что нужно скопировать домашний каталог со всем его содержимым в другую систему и у нас имеется жесткий диск, подключаемый к порту USB, который можно использовать для переноса файлов. В современных системах Linux такие диски «как по волшебству» автоматически монтируются в каталог <em>/media</em>. Допустим также, что подключаемый жесткий диск имеет том с именем <em>BigDisk</em>. Чтобы создать требуемый архив, выполним следующую команду:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>sudo tar cf /media/BigDisk/home.tar /home</strong></p>

    <p xml:lang="ru-RU">После записи файла следует отмонтировать диск и подключить его ко второму компьютеру. И снова он автоматически монтируется в каталог <em>/media/BigDisk</em>. Чтобы извлечь архив, выполните следующие команды:</p>

    <p class="list-first">[me@linuxbox2 ~]$ <strong>cd /</strong></p>

    <p class="list-last">[me@linuxbox2 /]$ <strong>sudo </strong><strong>tar xf /media/BigDisk/home.tar</strong></p>

    <p xml:lang="ru-RU">Обратите внимание, что здесь сначала выполняется переход в каталог <em>/</em>, чтобы извлечение производилось относительно корневого каталога, потому что все пути в архиве — относительные.</p>

    <p xml:lang="ru-RU">При распаковке архива можно ограничить количество извлекаемых данных. Например, можно извлечь из архива единственный файл:</p>

    <p class="list-one">tar xf <em>archive</em>.tar <em>путь_к_файлу</em></p>

    <p xml:lang="ru-RU">Добавление в конец команды пути к файлу гарантирует извлечение только этого файла. Можно указать несколько путей. Обратите внимание, что путь к файлу должен быть полным относительным путем в архиве. Обычно в путях к файлам нельзя использовать групповые символы; но GNU-версия <span class="command char-style-override-1">tar</span> (именно эта версия входит в состав большинства дистрибутивов Linux) поддерживает параметр <span class="command char-style-override-1">--wildcards</span>. В следующем примере используется файл <em>playground2.tar</em>, созданный выше:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>cd foo</strong></p>

    <p class="list-last">[me@linuxbox foo]$ <strong>tar xf ../playground2.tar --wildcards 'home/me/playground/ dir-*/file-A'</strong></p>

    <p xml:lang="ru-RU">Эта команда извлечет только файлы, соответствующие указанному пути с групповым символом <em>dir-*</em>.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">tar</span> часто используется в сочетании с <span class="command char-style-override-1">find</span>. В следующем примере коман­да <span class="command char-style-override-1">find</span> используется для поиска файлов, подлежащих включению в архив:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -name 'file-A' -exec tar rf playground.tar '{}' '+'</strong></p>

    <p xml:lang="ru-RU">Здесь команда <span class="command char-style-override-1">find</span> отыскивает в каталоге <em>playground</em> все файлы с именем <em>file-A</em> и затем с помощью операции <span class="command char-style-override-1">-exec</span> вызывает <span class="command char-style-override-1">tar</span> в режиме добавления в конец (<span class="command char-style-override-1">r</span>), чтобы добавить найденные файлы в архив <em>playground.</em><em>tar</em>.</p>

    <p xml:lang="ru-RU">Использование <span class="command char-style-override-1">tar</span> в сочетании с <span class="command char-style-override-1">find</span> предоставляет отличный способ <em>инкрементного резервного копирования</em> дерева каталогов или всей системы. Применяя <span class="command char-style-override-1">find</span> для поиска файлов, более новых, чем эталонный файл, определяющий отметку времени, можно создать архив, содержащий только более новые файлы, чем файлы предыдущего архива, при этом предполагается, что время последнего изменения эталонного файла будет изменяться сразу после создания архива.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">tar</span> способна также использовать стандартный ввод и стандартный вывод. Например:</p>

    <p class="list-first">[me@linuxbox foo]$ <strong>cd</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>find playground -name 'file-A' | tar cf - --files-from=- | gzip &gt; playground.tgz</strong></p>

    <p xml:lang="ru-RU">Здесь программа <span class="command char-style-override-1">find</span> создает список файлов и передает его по конвейеру программе <span class="command char-style-override-1">tar</span>. Когда программе <span class="command char-style-override-1">tar</span> передается имя файла <em>-</em> (дефис), под ним подразу­мевается стандартный ввод или стандартный вывод, в зависимости от контекста. (Кстати, соглашение об использовании дефиса (<em>-</em>) для представления стандартного ввода/вывода используется также многими другими программами.) Параметр <span class="command char-style-override-1">--files-from</span> (который можно заменить эквивалентным параметром <span class="command char-style-override-1">-T</span>) заставляет <span class="command char-style-override-1">tar</span> читать список путей из файла, а не из командной строки. Наконец, архив, произведенный программой <span class="command char-style-override-1">tar</span>, передается по конвейеру программе <span class="command char-style-override-1">gzip</span>, чтобы в результате получить сжатый архив <em>playground.tgz</em>. Расширение <em>.tgz</em> по общепринятому соглашению используется для tar-архивов, сжатых программой <span class="command char-style-override-1">gzip</span>. В некоторых случаях используется расширение <em>.tar.gz</em>.</p>

    <p xml:lang="ru-RU">В примере, приведенном выше, для сжатия архива использовалась внешняя программа <span class="command char-style-override-1">gzip</span>, однако современные GNU-версии <span class="command char-style-override-1">tar</span> поддерживают возможность gzip- и bzip2-сжатия своими встроенными средствами, для чего служат параметры <span class="command char-style-override-1">z</span> и <span class="command char-style-override-1">j</span> соответственно. Взяв за основу предыдущий пример, его можно упростить, как показано ниже:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -name 'file-A' | tar czf playground.tgz -T -</strong></p>

    <p xml:lang="ru-RU">Если, напротив, понадобится создать архив, сжатый в формате bzip2, это можно сделать так:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -name 'file-A' | tar cjf playground.tbz -T -</strong></p>

    <p xml:lang="ru-RU">Произведя простую замену параметра сжатия <span class="command char-style-override-1">z</span> на <span class="command char-style-override-1">j</span> (и изменив расширение выходного файла на <em>.tbz</em>, указывающее, что для сжатия использовался алгоритм bzip2), мы задействовали bzip2-сжатие.</p>

    <p xml:lang="ru-RU">Другой интересный пример использования поддержки стандартного ввода и вывода командой <span class="command char-style-override-1">tar</span> связан с передачей файлов между системами по сети. Представьте, что имеется две машины, действующие под управлением Unix-подобных систем и имеющие программы <span class="command char-style-override-1">tar</span> и <span class="command char-style-override-1">ssh</span>. В этом случае можно организовать передачу каталога из удаленной системы (с именем <span class="command char-style-override-1">remote-sys</span> в этом примере) в локальную:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir remote-stuff</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>cd remote-stuff</strong></p>

    <p class="listing-body">[me@linuxbox remote-stuff]$ <strong>ssh remote-sys 'tar cf - Documents' | tar xf -</strong></p>

    <p class="listing-body">me@remote-sys's password:</p>

    <p class="listing-body">[me@linuxbox remote-stuff]$ <strong>ls</strong></p>

    <p class="list-last">Documents</p>

    <p xml:lang="ru-RU">Здесь мы скопировали каталог <em>Documents</em> из удаленной системы <span class="command char-style-override-1">remote-sys</span> в каталог с именем <em>remote-stuff</em> в локальной системе. Как это получилось? Во-первых, мы запустили программу <span class="command char-style-override-1">tar</span> в удаленной системе с помощью команды <span class="command char-style-override-1">ssh</span>. Как вы наверняка помните, <span class="command char-style-override-1">ssh</span> позволяет выполнить программу на удаленном компьютере в сети и «увидеть» результат в локальной системе — стандартный вывод, полученный в удаленной системе, пересылается в локальную систему для обзора. Мы воспользовались этой особенностью и заставили <span class="command char-style-override-1">tar</span> создать архив (режим <span class="command char-style-override-1">c</span>) и вывести его не в файл, а в стандартный вывод (параметр <span class="command char-style-override-1">f</span> с дефисом в качестве аргумента), вследствие чего архив передается через шифрованный туннель, созданный программой <span class="command char-style-override-1">ssh</span>, локальной системе. В локальной системе мы вызвали <span class="command char-style-override-1">tar</span> с целью распаковать архив (режим <span class="command char-style-override-1">x</span>), полученный со стандартного ввода (все тот же параметр <span class="command char-style-override-1">f</span> с дефисом в качестве аргумента).</p>

    <h3 xml:lang="ru-RU">zip — упаковывание и сжатие файлов</h3>

    <p class="Normal0" xml:lang="ru-RU">Программа <span class="command char-style-override-1">zip</span> одновременно является и инструментом сжатия, и архиватором. Формат файлов, используемый программой, знаком пользователям Windows — программа читает и создает файлы с расширением <em>.zip</em>. Однако в Linux чаще других используется программа сжатия <span class="command char-style-override-1">gzip</span>, а второе место занимает <span class="command char-style-override-1">bzip2</span>. Пользователи Linux используют <span class="command char-style-override-1">zip</span> в основном для обмена файлами с системами Windows, а не как основной инструмент сжатия и архивирования.</p>

    <p xml:lang="ru-RU">В простейшем случае программа <span class="command char-style-override-1">zip</span> имеет следующий синтаксис:</p>

    <p class="list-one">zip <em>параметры</em> <em>сжатый_файл файл</em>...</p>

    <p xml:lang="ru-RU">Например, ниже показано, как создать zip-архив нашей песочницы:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>zip -r playground.zip playground</strong></p>

    <p xml:lang="ru-RU">Без параметра <span class="command char-style-override-1">-r</span> (отвечает за рекурсивный обход каталогов) в архив будет включен только каталог <em>playground</em> (без своего содержимого). Расширение <em>.zip</em> добавляется к имени выходного файла автоматически, а мы включили его в пример для наглядности.</p>

    <p xml:lang="ru-RU">В процессе создания zip-архива программа <span class="command char-style-override-1">zip</span> обычно выводит последовательность сообщений, как показано ниже:</p>

    <p class="list-first">adding: playground/dir-020/file-Z (stored 0%)</p>

    <p class="listing-body">adding: playground/dir-020/file-Y (stored 0%)</p>

    <p class="listing-body">adding: playground/dir-020/file-X (stored 0%)</p>

    <p class="listing-body">adding: playground/dir-087/ (stored 0%)</p>

    <p class="list-last">adding: playground/dir-087/file-S (stored 0%)</p>

    <p xml:lang="ru-RU">Эти сообщения показывают состояние каждого файла, добавленного в архив. <span class="command char-style-override-1">zip</span> добавляет файлы в архив, используя один из двух методов: либо «store» (простое сохранение) — без сжатия, как в примере, приведенном выше, либо «deflate» — со сжатием. Числовое значение, следующее за названием метода добавления, указывает достигнутую степень сжатия. Поскольку в нашей песочнице хранятся только пустые файлы, сжатие их содержимого не производится.</p>

    <p xml:lang="ru-RU">Извлечение содержимого из zip-архива выполняется просто — с помощью программы <span class="command char-style-override-1">unzip</span>:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>cd foo</strong></p>

    <p class="list-last">[me@linuxbox foo]$ <strong>unzip ../playground.zip</strong></p>

    <p xml:lang="ru-RU">Одно важное отличие <span class="command char-style-override-1">zip</span> (от <span class="command char-style-override-1">tar</span>) состоит в том, что если указанный архив существует, он дополняется, а не замещается. То есть существующий архив сохраняется, новые файлы добавляются в него, а существующие — замещаются.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">unzip</span> позволяет выводить информацию о файлах и выборочно извлекать их, достаточно только передать ей имя интересующего нас файла:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>unzip -l playground.zip playground/dir-087/file-Z</strong></p>

    <p class="listing-body">Archive:&nbsp;&nbsp;./playground.zip</p>

    <p class="listing-body">&nbsp;&nbsp;Length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Date&nbsp;&nbsp;&nbsp;Time&nbsp;&nbsp;&nbsp;Name</p>

    <p class="listing-body">--------&nbsp;&nbsp;&nbsp;&nbsp;----&nbsp;&nbsp;&nbsp;----&nbsp;&nbsp;&nbsp;----</p>

    <p class="listing-body">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;10-05-12 09:25&nbsp;&nbsp;playground/dir-087/file-Z</p>

    <p class="listing-body">--------&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------</p>

    <p class="listing-body">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 file</p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>cd foo</strong></p>

    <p class="listing-body">[me@linuxbox foo]$ <strong>unzip ../playground.zip playground/dir-087/file-Z</strong></p>

    <p class="listing-body">Archive: ../playground.zip</p>

    <p class="listing-body">replace playground/dir-087/file-Z? [y]es, [n]o, [A]ll, [N]one, [r]ename: <strong>y</strong></p>

    <p class="list-last">&nbsp;&nbsp;extracting: playground/dir-087/file-Z</p>

    <p xml:lang="ru-RU">При наличии параметра <span class="command char-style-override-1">-l</span> программа <span class="command char-style-override-1">unzip</span> просто выведет информацию о содержимом архива, не извлекая файл. Если имя файла (или файлов) не указано, <span class="command char-style-override-1">unzip</span> выведет список всех файлов в архиве. Для получения более подробной информации следует добавить параметр <span class="command char-style-override-1">-v</span>. Обратите внимание, что когда при извлечении из архива обнаруживается конфликт с существующим файлом, перед его заменой у пользователя запрашивается разрешение.</p>

    <p xml:lang="ru-RU">Подобно программе <span class="command char-style-override-1">tar</span> <span class="command char-style-override-1">zip</span> может использовать стандартный ввод и вывод, хотя реализация этой возможности имеет меньшую практическую ценность. С помощью параметра <span class="command char-style-override-1">-@</span> программе <span class="command char-style-override-1">zip</span> по конвейеру передается список имен файлов:</p>

    <p class="list-first">[me@linuxbox foo]$ <strong>cd</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>find playground -name "file-A" | zip -@ file-A.zip</strong></p>

    <p xml:lang="ru-RU">Здесь команда <span class="command char-style-override-1">find</span> генерирует список файлов, соответствующих проверке <span class="command char-style-override-1">-name "file-A"</span>, и передает его по конвейеру команде <span class="command char-style-override-1">zip</span>, которая затем создает архив <em>file-A.zip</em> с выбранными файлами.</p>

    <p xml:lang="ru-RU"><span class="command char-style-override-1">zip</span> также поддерживает запись результатов своей работы в стандартный вывод, но эта особенность имеет ограниченное применение, потому что очень немногие программы способны работать с форматом zip. К сожалению, программа <span class="command char-style-override-1">unzip</span> не принимает входные данные со стандартного ввода. Это препятствует совместному использованию <span class="command char-style-override-1">zip</span> и <span class="command char-style-override-1">unzip</span> для копирования файлов по сети, как это возможно с программой <span class="command char-style-override-1">tar</span>.</p>

    <p xml:lang="ru-RU"><span class="command char-style-override-1">zip</span>, в свою очередь, способна принимать данные со стандартного ввода, поэтому ее можно использовать для сжатия вывода других программ:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>ls -l /etc/ | zip ls-etc.zip -</strong></p>

    <p class="list-last">adding: - (deflated 80%)</p>

    <p xml:lang="ru-RU">В этом примере вывод команды <span class="command char-style-override-1">ls</span> передается по конвейеру программе <span class="command char-style-override-1">zip</span>. Так же как <span class="command char-style-override-1">tar</span>, <span class="command char-style-override-1">zip</span> интерпретирует завершающий дефис как требование «использовать стандартный ввод вместо файла».</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">unzip</span> позволяет направить ее результаты в стандартный вывод, для чего следует передать параметр <span class="command char-style-override-1">-p</span> (pipe — конвейер):</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>unzip -p ls-etc.zip | less</strong></p>

    <p xml:lang="ru-RU">Мы затронули лишь самые основные возможности программ <span class="command char-style-override-1">zip</span> и <span class="command char-style-override-1">unzip</span>. Обе они имеют множество параметров, придающих им большую гибкость, хотя некоторые из них допустимы только для определенных платформ. Для обеих программ, <span class="command char-style-override-1">zip</span> и <span class="command char-style-override-1">unzip</span>, имеются подробные страницы справочного руководства (<span class="command char-style-override-1">man</span>) с множеством полезных примеров.</p>

    <h2 id="toc_marker-23-3" xml:lang="ru-RU">Синхронизация файлов и каталогов</h2>

    <p class="Normal0" xml:lang="ru-RU">В задачах резервного копирования систем широко используется стратегия синхронизации одного или нескольких каталогов с другими каталогами, находящимися в локальной системе (обычно на некотором извлекаемом устройстве) или в удаленной. Можно, к примеру, создать локальную копию веб-сайта, находящегося в разработке, и синхронизировать ее время от времени с «рабочей» копией на удаленном веб-сервере.</p>

    <h3 xml:lang="ru-RU">rsync — синхронизация файлов и каталогов с удаленной системой</h3>

    <p class="Normal0" xml:lang="ru-RU">В мире Unix-подобных систем для решения этой задачи широко используется инструмент <span class="command char-style-override-1">rsync</span>. Эта программа синхронизует локальные и удаленные каталоги, используя протокол <em>rsync remote-update</em> (протокол удаленного обновления rsync), который позволяет <span class="command char-style-override-1">rsync</span> быстро обнаруживать различия между двумя каталогами и копировать минимальный объем данных, необходимый для синхронизации. Это делает программу <span class="command char-style-override-1">rsync</span> быстрой и экономичной по сравнению с другими программами копирования.</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">rsync</span> имеет следующий синтаксис:</p>

    <p class="listing-body">rsync <em>параметры источник приемник</em></p>

    <p xml:lang="ru-RU">где роль источника и приемника могут играть:</p>

    <p class="ListBul" xml:lang="ru-RU">• локальный файл или каталог;</p>

    <p class="ListBul" xml:lang="ru-RU">• удаленный файл или каталог в форме <em>[пользователь@]хост:путь</em>;</p>

    <p class="ListBulLast" xml:lang="ru-RU">• удаленный сервер rsync, определяемый идентификатором URI <em>rsync://[пользователь@]хост[:порт]/путь</em>.</p>

    <p xml:lang="ru-RU">Обратите внимание, что либо источник, либо приемник должен находиться в локальной системе. Копирование из удаленной системы в удаленную систему не поддерживается.</p>

    <p xml:lang="ru-RU">Давайте попробуем синхронизировать несколько локальных файлов. Сначала очистим наш каталог <em>foo</em>:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>rm -rf foo/*</strong></p>

    <p xml:lang="ru-RU">Далее синхронизируем каталог <em>playground</em> с соответствующей копией в <em>foo</em>:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>rsync -av playground foo</strong></p>

    <p xml:lang="ru-RU">Мы добавили два параметра: <span class="command char-style-override-1">-</span><span class="command char-style-override-1">a</span> (для архивирования — обеспечивает рекурсивный обход и сохранение атрибутов файлов) и <span class="command char-style-override-1">-v</span> (подробный вывод), чтобы отразить каталог <em>playground</em> в каталог <em>foo</em>. В процессе выполнения команды можно просматривать список копируемых файлов и каталогов. В конце программа выведет итоговое сообщение, как показано ниже, включающее общий объем скопированных данных:</p>

    <p class="list-first">sent 135759 bytes&nbsp;&nbsp;received 57870 bytes&nbsp;&nbsp;387258.00 bytes/sec</p>

    <p class="list-last">total size is 3230&nbsp;&nbsp;speedup is 0.02</p>

    <p xml:lang="ru-RU">Если теперь запустить команду еще раз, результат будет другой:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>rsync -av playgound foo</strong></p>

    <p class="listing-body">building file list ... done</p>

    <p class="listing-body">&nbsp;</p>

    <p class="listing-body">sent 22635 bytes&nbsp;&nbsp;received 20 bytes&nbsp;&nbsp;45310.00 bytes/sec</p>

    <p class="list-last">total size is 3230&nbsp;&nbsp;speedup is 0.14</p>

    <p xml:lang="ru-RU">Обратите внимание на отсутствие списка файлов. Это объясняется тем, что программа <span class="command char-style-override-1">rsync</span> не обнаружила различий между <em>~/playground</em> и <em>~/foo/playground</em> и поэтому ничего не скопировала. Если теперь изменить файл в <em>playground</em> и запустить <span class="command char-style-override-1">rsync</span> еще раз, она обнаружит изменившийся файл и скопирует только его.</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>touch playground/dir-099/file-Z</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>rsync -av playground foo</strong></p>

    <p class="listing-body">building file list ... done</p>

    <p class="listing-body">playground/dir-099/file-Z</p>

    <p class="listing-body">sent 22685 bytes&nbsp;&nbsp;received 42 bytes&nbsp;&nbsp;45454.00 bytes/sec</p>

    <p class="list-last">total size is 3230&nbsp;&nbsp;speedup is 0.14</p>

    <p xml:lang="ru-RU">В качестве примера представьте воображаемый внешний жесткий диск, использовавшийся выше с командой <span class="command char-style-override-1">tar</span>. Если после подключения такого диска к системе он снова будет смонтирован в каталог <em>/media/BigDisk</em>, выполним первое резервное копирование системы, для начала создав каталог <em>/backup</em> на внешнем устройстве, а затем вызвав <span class="command char-style-override-1">rsync</span> для копирования наиболее важных компонентов системы на внешнее устройство:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir /media/BigDisk/backup</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup</strong></p>

    <p xml:lang="ru-RU">В этом примере мы скопировали каталоги <em>/etc</em>, <em>/home</em> и <em>/usr/local</em> из нашей системы на воображаемый внешний диск. Мы добавили параметр <span class="command char-style-override-1">--delete</span>, чтобы удалить файлы, которые могут присутствовать на устройстве с резервной копией, но отсутствовать на устройстве-источнике (этот параметр не нужен при создании резервной копии в первый раз, но является полезным дополнением в последующих операциях копирования). Периодическое повторение процедуры подключения внешнего диска и запуск этой команды <span class="command char-style-override-1">rsync</span> является неплохим (хотя и не идеальным) способом сохранения резервной копии небольшой системы. Конечно, здесь также могло бы пригодиться создание псевдонима. Определим псевдоним и добавим его в свой файл <em>.bashrc</em>, чтобы обеспечить возможность быстрого резервного копирования:</p>

    <p class="list-one">alias backup='sudo rsync -av --delete /etc /home /usr/local /media/BigDisk/backup'</p>

    <p xml:lang="ru-RU">Теперь, чтобы выполнить всю работу, достаточно просто подключить внешний диск и ввести команду <span class="command char-style-override-1">backup</span>.</p>

    <h3 xml:lang="ru-RU">Использование rsync для копирования по сети</h3>

    <p class="Normal0" xml:lang="ru-RU">Одно из самых больших достоинств <span class="command char-style-override-1">rsync</span> — возможность копирования файлов по сети, об этом нам «говорит» буква <em>r</em> в названии <span class="command char-style-override-1">rsync</span>, что означает <em>remote</em> (удаленная). Удаленную синхронизацию можно выполнить одним из двух способов.</p>

    <p xml:lang="ru-RU">Первый можно использовать с удаленными системами, где установлена <span class="command char-style-override-1">rsync</span> и программа удаленной командной оболочки, такая как <span class="command char-style-override-1">ssh</span>. Допустим, что в локальной сети имеется другая система с огромным объемом дискового пространства и мы хотели бы использовать эту систему для хранения резервной копии вместо внешнего диска. Если допустить, что в этой системе уже имеется каталог <em>/backup</em>, куда можно было бы сохранить наши файлы, мы могли бы выполнить резервное копирование так:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remotesys:/backup</strong></p>

    <p xml:lang="ru-RU">Мы внесли два изменения в команду, чтобы обеспечить копирование по сети. Во-первых, добавили параметр <span class="command char-style-override-1">--rsh=ssh</span>, который требует от <span class="command char-style-override-1">rsync</span> использовать в качестве удаленной командной оболочки программу <span class="command char-style-override-1">ssh</span>. Благодаря этому для передачи данных из локальной системы в удаленную мы можем использовать шифрованный туннель SSH. Во-вторых, мы добавили имя удаленного узла (в данном примере <em>remote-sys</em>) перед именем удаленного каталога.</p>

    <p xml:lang="ru-RU">Второй способ использования <span class="command char-style-override-1">rsync</span> для синхронизации файлов по сети заключается в использовании <em>сервера rysnc</em>. <span class="command char-style-override-1">rsync</span> можно настроить на работу в режиме демона, принимающего входящие запросы на синхронизацию. Этот прием часто используется для зеркалирования удаленных систем. Например, компания Red Hat Software поддерживает огромный репозиторий программных пакетов, разрабатываемых для ее дистрибутива Fedora. Для специалистов, занимающихся тестированием программного обеспечения, очень удобно иметь зеркало этой коллекции в ходе этапа тестирования, предшествующего этапу выпуска дистрибутива. Поскольку файлы в репозитории обновляются достаточно часто (порой по нескольку раз в день), неплохо было бы организовать периодическую синхронизацию локального зеркала вместо копирования всего объема репозитория. Один из таких репозиториев хранится в университете Georgia Tech; мы могли бы создать его зеркало с помощью локальной программы <span class="command char-style-override-1">rsync</span> и сервера rsync в Georgia Tech:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir fedora-devel</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linux-core/development/i386/os fedora-devel</strong></p>

    <p xml:lang="ru-RU">В этом примере мы использовали идентификатор URI удаленного сервера rsync, включающий протокол (<em>rsync://</em>), имя удаленного узла (<em>rsync.gtlib.gatech.edu</em>) и путь к репозиторию.</p>
  </div>

</body></html>