<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Командная строка Linux</title>
  <link href="../Styles/template.css" rel="stylesheet" type="text/css"/>
</head>

<body id="x978549602303" xml:lang="en-US">
  <div class="Basic-Text-Frame">
     <h1 id="toc_marker-22" xml:lang="ru-RU">17. Поиск файлов</h1>

    <p class="Normal0" xml:lang="ru-RU">Блуждая по системе Linux, мы совершенно ясно увидели, что типичная Linux-система содержит множество файлов. В связи с этим возникает вопрос: как искать нужные файлы? Мы уже знаем, что файловая система в Linux организована в соответствии с определенными соглашениями, которые переходили из одного поколения Unix-подобных систем в другое, но огромное число файлов может порождать труднопреодолимую проблему.</p>

    <p xml:lang="ru-RU">В этой главе мы рассмотрим два инструмента для поиска файлов в системе:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• locate</span> – выполняет поиск файлов по именам.</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• find</span> – выполняет поиск файлов в иерархии каталогов.</p>

    <p xml:lang="ru-RU">Мы также познакомимся с командой, часто используемой вместе с командами поиска файлов для обработки списков с результатами:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• xargs</span> – конструирует команды на основе данных, полученных из стандартного ввода, и выполняет их.</p>

    <p xml:lang="ru-RU">Дополнительно в этой главе будет представлена пара команд, которые помогут нам в наших исследованиях:</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• touch</span> – изменяет времена, ассоциированные с файлом.</p>

    <p class="ListBul" xml:lang="ru-RU"><span class="command char-style-override-1">• stat</span> – выводит статус файла или файловой системы.</p>

    <h2 id="toc_marker-22-1" xml:lang="ru-RU">locate — простой способ поиска файлов</h2>

    <p class="Normal0" xml:lang="ru-RU">Программа <span class="command char-style-override-1">locate</span> выполняет быстрый поиск в базе данных имен файлов и выводит все имена, соответствующие искомой строке. Допустим, к примеру, что нужно найти все программы с именами, начинающимися с <span class="command char-style-override-1">zip</span>. Поскольку требуется найти программы, можно предположить, что имя каталога с программами оканчивается на <span class="command char-style-override-1">bin/</span>. Соответственно можно попробовать выполнить поиск с помощью <span class="command char-style-override-1">locate</span>, как показано ниже:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>locate bin/zip</strong></p>

    <p xml:lang="ru-RU"><span class="command char-style-override-1">locate</span> выполнит поиск в базе данных имен файлов и выведет все имена, содержащие строку <span class="command char-style-override-1">bin/zip</span>:</p>

    <p class="list-first">/usr/bin/zip</p>

    <p class="listing-body">/usr/bin/zipcloak</p>

    <p class="listing-body">/usr/bin/zipgrep</p>

    <p class="listing-body">/usr/bin/zipinfo</p>

    <p class="listing-body">/usr/bin/zipnote</p>

    <p class="list-one">/usr/bin/zipsplit</p>

    <p xml:lang="ru-RU">Если к результатам поиска предъявляются более строгие требования, команду <span class="command char-style-override-1">locate</span> можно объединить с другими инструментами, такими как <span class="command char-style-override-1">grep</span>, позволяющими осуществить более сложный поиск:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>locate zip | grep bin</strong></p>

    <p class="listing-body">/bin/bunzip2</p>

    <p class="listing-body">/bin/bzip2</p>

    <p class="listing-body">/bin/bzip2recover</p>

    <p class="listing-body">/bin/gunzip</p>

    <p class="listing-body">/bin/gzip</p>

    <p class="listing-body">/usr/bin/funzip</p>

    <p class="listing-body">/usr/bin/gpg-zip</p>

    <p class="listing-body">/usr/bin/preunzip</p>

    <p class="listing-body">/usr/bin/prezip</p>

    <p class="listing-body">/usr/bin/prezip-bin</p>

    <p class="listing-body">/usr/bin/unzip</p>

    <p class="listing-body">/usr/bin/unzipsfx</p>

    <p class="listing-body">/usr/bin/zip</p>

    <p class="listing-body">/usr/bin/zipcloak</p>

    <p class="listing-body">/usr/bin/zipgrep</p>

    <p class="listing-body">/usr/bin/zipinfo</p>

    <p class="listing-body">/usr/bin/zipnote</p>

    <p class="list-last">/usr/bin/zipsplit</p>

    <p xml:lang="ru-RU">Программа <span class="command char-style-override-1">locate</span> существует уже много лет, и за эти годы было создано несколько ее вариантов, получивших широкое распространение. Два из них, наиболее часто используемые в современных дистрибутивах Linux, — это <span class="command char-style-override-1">slocate</span> и <span class="command char-style-override-1">mlocate</span>, которые, впрочем, являются символическими ссылками, указывающими на <span class="command char-style-override-1">locate</span>. Разные версии <span class="command char-style-override-1">locate</span> имеют пересекающиеся множества параметров. Некоторые поддерживают поиск с использованием регулярных выражений (о которых рассказывается в главе 19) и групповые символы. Загляните на страницу справочного руководства (<span class="command char-style-override-1">man</span>) для <span class="command char-style-override-1">locate</span>, чтобы определить, какая версия установлена у вас.</p>

    <p class="Vrezka-head" xml:lang="ru-RU">откуда берется база данных для locate?</p>

    <p class="Vrezka-body" xml:lang="ru-RU">В некоторых дистрибутивах при попытке запустить <span class="command char-style-override-1">locate</span> сразу после установки она потерпит неудачу, но если попытаться использовать ее на следующий день, все, как ни странно будет работать как надо. Так в чем же проблема? База данных для <span class="command char-style-override-1">locate</span> создается другой программой с именем <span class="command char-style-override-1">updatedb</span>. Обычно она периодически запускается как <em>задание</em> <em>cron</em>; то есть она запускается системным планировщиком <span class="command char-style-override-1">cron</span> через регулярные интервалы времени. В большинстве систем, в состав которых входит <span class="command char-style-override-1">locate</span>, программа <span class="command char-style-override-1">updatedb</span> запускается один раз в сутки. Поскольку база данных не обновляется непрерывно, скорее всего, <span class="command char-style-override-1">locate</span> не находит самые свежие файлы. Чтобы решить эту проблему, запустите программу <span class="command char-style-override-1">updatedb</span> вручную от имени суперпользователя.</p>

    <h2 id="toc_marker-22-2" xml:lang="ru-RU">find — сложный способ поиска файлов</h2>

    <p class="Normal0" xml:lang="ru-RU">В отличие от программы <span class="command char-style-override-1">locate</span>, выполняющей поиск файлов по именам, программа <span class="command char-style-override-1">find</span> ищет файлы согласно заданным атрибутам в указанном каталоге (и во вложенных подкаталогах). Далее мы потратим время на исследование команды <span class="command char-style-override-1">find</span>, потому что она имеет множество интересных особенностей, с которыми мы неоднократно столкнемся, когда начнем знакомиться с приемами программирования в последующих главах.</p>

    <p xml:lang="ru-RU">В простейшем случае программе <span class="command char-style-override-1">find</span> можно передать одно или несколько имен каталогов для поиска. Например, с ее помощью можно получить список содержимого домашнего каталога:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find ~</strong></p>

    <p xml:lang="ru-RU">Для большинства активных пользователей она выдаст длинный список. Так как список выводится в стандартный вывод, его можно передать по конвейеру другим программам. Воспользуемся программой <span class="command char-style-override-1">wc</span>, чтобы подсчитать число файлов:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find ~ | wc -l</strong></p>

    <p class="list-last">47068</p>

    <p xml:lang="ru-RU">Ух ты, вот это мы поработали! Вся прелесть команды <span class="command char-style-override-1">find</span> в том, что ее можно использовать для поиска файлов, соответствующих определенным критериям. Она делает это посредством (что немного странно) применения <em>проверок</em>, <em>операций</em> и <em>параметров</em>. Сначала рассмотрим проверки.</p>

    <h3 xml:lang="ru-RU">Проверки</h3>

    <p class="Normal0" xml:lang="ru-RU">Допустим, мы хотим получить список каталогов. Для этого добавим в команду следующую проверку:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find ~ -type d | wc -l</strong></p>

    <p class="list-last">1695</p>

    <p xml:lang="ru-RU">Добавив проверку <span class="command char-style-override-1">-type d</span>, мы ограничились поиском только каталогов. Но точно так же можно ограничить поиск только обычными файлами:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find ~ -type f | wc -l</strong></p>

    <p class="list-last">38737</p>

    <p xml:lang="ru-RU">В табл. 17.1 перечислены проверки типов файлов,&#160;&#160;наиболее часто используемых с командой <span class="command char-style-override-1">find</span>.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.1.</strong> Проверки типов файлов в find</p>

    <table id="table-70" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2 cell-style-override-8">       <p class="Tabl-head" xml:lang="ru-RU">Тип файлов</p>

</td>

      <td class="Cell-Style-2 cell-style-override-8">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">b</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU">Специальный файл блочного устройства</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">c</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU">Специальный файл символьного устройства</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">d</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU">Каталог</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">f</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU">Обычный файл</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">l</span></p>

</td>

      <td class="Cell-Style-1 cell-style-override-8">       <p class="Tabl-body" xml:lang="ru-RU">Символическая ссылка</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Добавив дополнительные проверки, можно выполнять поиск файлов по размеру и имени. Давайте найдем все обычные файлы с именами, соответствующими шаблону <em>*.JPG</em>, и имеющие размер больше 1 мегабайта:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find ~ -type f -name "*.JPG" -size +1M | wc -l</strong></p>

    <p class="list-last">840</p>

    <p xml:lang="ru-RU">В этом примере мы добавили проверку <span class="command char-style-override-1">-name</span> с шаблоном имени файла. Обратите внимание, что шаблон заключен в кавычки, чтобы предотвратить подстановку имен файлов командной оболочкой. Далее мы добавили проверку <span class="command char-style-override-1">-size</span> со строкой <span class="command char-style-override-1">+1M</span>. Начальный символ «плюс» указывает, что требуется искать файлы, размер которых превышает указанное число. Начальный символ «минус» изменил бы значение строки на противоположное: «меньше указанного числа». Число без знака означает: «в точности соответствует значению». Буква <span class="command char-style-override-1">M</span> в конце определяет единицы измерения – мегабайты (Megabytes). В табл. 17.2 перечислены символы, которые можно использовать для обозначения единиц измерения.</p>

    <p xml:lang="ru-RU">Команда <span class="command char-style-override-1">find</span> поддерживает множество разнообразных проверок. В табл. 17.3 приводится краткое описание наиболее часто используемых из них. Обратите внимание, что в случаях, когда требуется числовой аргумент, допустимо использование формы записи с символами <span class="command char-style-override-1">+</span> и <span class="command char-style-override-1">-</span>, обсуждавшейся выше.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.2.</strong> Единицы измерения, поддерживаемые командой find</p>

    <table id="table-71" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <thead>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Символ</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Единица измерения</p>

</td>

</tr>

</thead>

      <tbody>      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">b</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Блоки размером по 512 байт (используется по умолчанию, если иное не указано явно)</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">c</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Байты</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">w</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">2-байтные слова</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">k</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Килобайты (Kilobytes, блоки по 1024 байт)</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">M</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Мегабайты (Megabytes,&#160;&#160;блоки по 1 048 576 байт)</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">G</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Гигабайты (Gigabytes, блоки по 1 073 741 824 байт)</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.3.</strong> Проверки, поддерживаемые командой find</p>

    <table id="table-72" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <thead>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Проверка</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

</thead>

      <tbody>      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-cmin n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, содержимое или атрибуты которых последний раз изменялись точно <span class="command char-style-override-4">n</span> минут назад. Чтобы выразить условие «менее <span class="command char-style-override-4">n</span> минут назад», используйте <span class="command char-style-override-4">-n</span>; чтобы выразить условие «более <span class="command char-style-override-4">n</span> минут назад», используйте <span class="command char-style-override-4">+n</span><span class="command char-style-override-4"></span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-cnewer имя</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, содержимое или атрибуты которых последний раз изменялись позже, чем у файла с указанным именем</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-ctime n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, содержимое или атрибуты (то есть разрешения) которых последний раз изменялись более чем <span class="command char-style-override-4">n*24</span> часа назад</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-empty</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует пустым файлам и каталогам</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-group группа</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, принадлежащим указанной группе. Группа может задаваться именем или числовым идентификатором группы</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-iname шаблон</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Действует так же, как проверка <span class="command char-style-override-4">-name</span>, но различает регистр символов</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-inum n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам с номером индексного узла (inode) <span class="command char-style-override-4">n</span>. Эту проверку удобно использовать для поиска всех жестких ссылок на определенный индексный узел</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-mmin n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, содержимое которых последний раз изменялось <span class="command char-style-override-4">n</span> минут назад</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-mtime n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, содержимое которых последний раз изменялось <span class="command char-style-override-4">n*24</span> часов назад</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-name </span><span class="command char-style-override-4">шаблон</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам и каталогам, имена которых совпадают с указанным шаблоном</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-newer имя</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span>Соответствует файлам и каталогам, содержимое которых последний раз изменялось позже, чем у файла с указанным именем. Эта проверка может пригодиться в сценариях, выполняющих резервное копирование файлов. Каждый раз в процессе создания резервной копии можно обновлять файл (например, файл журнала) и затем с помощью </span><span class="command char-style-override-4">find</span><span> определять, какие файлы изменились с момента последнего обновления</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-nouser</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам и каталогам, не принадлежащим какому-либо допустимому пользователю. Эту проверку можно использовать для поиска файлов, принадлежащих удаленным учетным записям, или для обнаружения следов злоумышленников</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-nogroup</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам и каталогам, не принадлежащим какой-либо допустимой группе</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-perm режим</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам с указанным режимом доступа. Режим может выражаться восьмеричным числом или иметь символическую форму</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-samefile имя</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Действует так же, как проверка <span class="command char-style-override-4">-inum</span>. Соответствует файлам с тем же номером индексного узла (inode), что и файл с указанным именем</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-size </span><span class="command char-style-override-4">n</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам с размером <span class="command char-style-override-4">n</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-type c</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам с типом <span class="command char-style-override-4">c</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-user имя</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует файлам или каталогам, принадлежащим пользователю с указанным именем. Аргумент имя может быть именем или числовым идентификатором пользователя</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Это не полный список. Дополнительные детали ищите на странице справочного руководства (<span class="command char-style-override-1">man</span>) для команды <span class="command char-style-override-1">find</span>.</p>

    <h4 xml:lang="ru-RU">Операторы</h4>

    <p class="Normal0" xml:lang="ru-RU">Несмотря на большое число проверок, поддерживаемых командой <span class="command char-style-override-1">find</span>, мы все еще нуждаемся в способе определения <em>логических отношений</em> между проверками. Например, представьте, что в некотором каталоге мы хотим найти все файлы и подкаталоги с небезопасными разрешениями. Для этого можно было бы выполнить поиск всех файлов с разрешениями, отличающимися от 0600, и каталогов с разрешениями, отличающимися от 0700. К счастью, <span class="command char-style-override-1">find</span> поддерживает возможность комбинирования проверок с помощью логических операторов, с целью определить более сложные критерии отбора. Выразить вышеупомянутую проверку можно так:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find ~ \( -type f -not -perm 0600 \) -or \( -type d -not –perm 0700 \)</strong></p>

    <p xml:lang="ru-RU">Ф-фу! Как неизящно! Что все это значит? На самом деле операторы перестанут казаться избыточно сложными, как только вы с ними познакомитесь поближе (табл. 17.4).</p>

    <p xml:lang="ru-RU">Имея список операторов под рукой, попробуем разобрать команду <span class="command char-style-override-1">find</span>. На самом верхнем уровне мы видим, что проверки объединены в две группы, разделенные оператором <span class="command char-style-override-1">-or</span>:</p>

    <p class="list-one">(<em>выражение 1</em>) -or (<em>выражение 2</em>)</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.4.</strong> Логические операторы, поддерживаемые командой find</p>

    <table id="table-73" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Оператор</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-and</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует, если выполняются условия в проверках с обеих сторон от оператора. Можно сократить до <span class="command char-style-override-4">-a</span>. Обратите внимание, что в отсутствие операторов по умолчанию подразумевается <span class="command char-style-override-4">-and</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-or</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует, если выполняется условие с одной из сторон от оператора. Можно сократить до <span class="command char-style-override-4">-o</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-not</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Соответствует, если условие в проверке, следующей за оператором, не выполняется. Можно сократить до <span class="command char-style-override-4">-!</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">( )</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Группируют проверки и операторы для формирования крупных выражений. Используются для управления порядком проверок. По умолчанию проверки выполняются слева направо. Часто используются для изменения порядка проверок по умолчанию, чтобы получить желаемый результат. Даже если скобки не нужны, иногда полезно включать их, чтобы сделать команды более наглядными. Не забывайте, что круглые скобки имеют специальное значение для командной оболочки, поэтому их нужно экранировать, чтобы они передавались команде <span class="command char-style-override-4">find</span> как аргументы. Обычно экранирование выполняют с помощью символа обратного слеша</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">В этом есть определенный смысл, потому что мы хотим найти файлы с одним набором разрешений и каталоги – с другим. Но если выполняется поиск и файлов и каталогов, почему используется оператор <span class="command char-style-override-1">-or</span> вместо <span class="command char-style-override-1">-and</span>? Потому что <span class="command char-style-override-1">find</span>, выполняя обход файлов и каталогов, оценивает их по одному, чтобы понять, соответствует ли файл или каталог указанным проверкам. Команде требуется узнать, является ли очередной элемент файлом или каталогом с «плохими» разрешениями. Один и тот же элемент не может соответствовать сразу двум условиям. То есть если развернуть сгруппированные выражения, можно увидеть следующее:</p>

    <p class="list-one">(файл с плохими разрешениями) -or (каталог с плохими разрешениями)</p>

    <p xml:lang="ru-RU">Наша следующая задача — проверить «плохие разрешения». Как это сделать? Фактически никак. Но мы можем проверить «неудовлетворительные разрешения», зная, что такое «удовлетворительные разрешения». В случае с файлами удовлетворительными являются разрешения 0600, для каталогов — 0700. Выражение, проверяющее «неудовлетворительные» разрешения, выглядит так:</p>

    <p class="list-one">-type f -and -not -perms 0600</p>

    <p xml:lang="ru-RU">а для каталогов так:</p>

    <p class="list-one">-type d -and -not -perms 0700</p>

    <p xml:lang="ru-RU">Как отмечалось в табл. 17.4, оператор <span class="command char-style-override-1">-</span><span class="command char-style-override-1">and</span> можно просто удалить, так как он подразумевается по умолчанию. Теперь, объединив все вместе, мы получим окончательную команду:</p>

    <p class="list-one"><strong>find ~ (-type f -not -perms 0600) -or (-type d -not -perms 0700)</strong></p>

    <p xml:lang="ru-RU">Однако поскольку круглые скобки имеют специальное значение для командной оболочки, их нужно экранировать, чтобы предотвратить интерпретацию скобок командной оболочкой. Для этого достаточно добавить обратный слеш перед каждой из них.</p>

    <p xml:lang="ru-RU">Логические операторы имеют еще одну важную особенность, с которой необходимо разобраться. Представьте, что у нас есть два выражения, разделенных логическим оператором:</p>

    <p class="list-one"><em>выражение1 </em>-оператор<em> выражение2</em></p>

    <p xml:lang="ru-RU"><em>Выражение1</em> будет вычислено в любом случае, а вот будет ли вычислено <em>выражение2</em>, зависит от оператора. В табл. 17.5 показано, как это работает.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.5.</strong> Действие логических операторов -and/-or команды find</p>

    <table id="table-74" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Результат выражения1</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Оператор</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Выражение2...</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Истина</p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-and</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Всегда вычисляется</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Ложь</p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-and</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Никогда не вычисляется</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Истина</p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-or</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Никогда не вычисляется</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Ложь</p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-or</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Всегда вычисляется</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Почему так происходит? Это сделано для повышения производительности. Возьмем для примера оператор <span class="command char-style-override-1">-and</span>. Мы знаем, что выражение <span class="command char-style-override-1">выражение1 -and выражение2</span> не может быть истинным, если <span class="command char-style-override-1">выражение1</span> вернет ложный результат, поэтому нет смысла вычислять <span class="command char-style-override-1">выражение2</span>. Аналогично, если имеется выражение <span class="command char-style-override-1">выражение1</span> <span class="command char-style-override-1">-or</span> <span class="command char-style-override-1">выражение2</span> и <span class="command char-style-override-1">выражение1</span> вернет истинный результат, нет смысла вычислять <span class="command char-style-override-1">выражение2</span>, так как уже известно, что <span class="command char-style-override-1">выражение1 -or выражение2</span> является истинным.</p>

    <p xml:lang="ru-RU">Это удобно, поскольку такой порядок вычислений помогает повысить скорость выполнения. Но почему это так важно для нас? Потому что мы можем использовать данную особенность для управления выполнением операций, о которых рассказывается далее.</p>

    <h3 xml:lang="ru-RU">Операции</h3>

    <p class="Normal0" xml:lang="ru-RU">Давайте попробуем выполнить определенные действия в процессе поиска! Иметь список с результатами работы команды <span class="command char-style-override-1">find</span> уже неплохо, но представьте, что нам нужно выполнить некие операции с элементами списка. К счастью, <span class="command char-style-override-1">find </span>позволяет выполнять наши операции, основываясь на результатах поиска.</p>

    <h4 xml:lang="ru-RU">Предопределенные операции</h4>

    <p class="Normal0" xml:lang="ru-RU">Существует множество предопределенных операций и несколько способов применения операций, определяемых пользователем. Для начала взгляните на неполный список предопределенных операций в табл. 17.6.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.6.</strong> Предопределенные операции, поддерживаемые командой find</p>

    <table id="table-75" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Операция</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-delete</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Удаляет текущий найденный файл</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-ls</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Действует эквивалентно команде <span class="command char-style-override-4">ls -dils</span> в отношении найденного файла. Результат выводится в стандартный вывод</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-print</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Выводит полный путь к найденному файлу в стандартный вывод. Эта операция выполняется по умолчанию, если не указана никакая другая</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-quit</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Завершает выполнение команды после обнаружения первого совпадения</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Поддерживаемых операций намного больше, чем показано здесь. Полный список можно найти на странице справочного руководства (<span class="command char-style-override-1">man</span>) для команды <span class="command char-style-override-1">find</span>.</p>

    <p xml:lang="ru-RU">В нашем первом примере мы выполнили команду:</p>

    <p class="list-one"><strong>find ~</strong></p>

    <p xml:lang="ru-RU">Она выводит список всех файлов и подкаталогов, хранящихся в домашнем каталоге. Список выводится просто потому, что в отсутствие других операций предполагается операция <span class="command char-style-override-1">-print</span>. То есть эту команду можно было бы выразить так:</p>

    <p class="list-one"><strong>find ~ -print</strong></p>

    <p xml:lang="ru-RU">Программу <span class="command char-style-override-1">find</span> можно использовать для удаления файлов, соответствующих определенным критериям. Например, следующая команда удалит все файлы с расширением <em>.BAK</em> (которое часто используется для обозначений резервных копий файлов):</p>

    <p class="list-one"><strong>find ~ -type f -name '*.BAK' -delete</strong></p>

    <p xml:lang="ru-RU">Эта команда найдет в домашнем каталоге (и во вложенных подкаталогах) пользователя все файлы с расширением <em>.BAK</em> и удалит их.</p>

    <p class="Vrezka-head" xml:lang="ru-RU">ВНИМАНИЕ</p>

    <p class="Vrezka-body" xml:lang="ru-RU">Обратите внимание, что операцию <span class="command char-style-override-1">-delete</span> следует использовать <strong>с особыми предосторожностями</strong>. Всегда предварительно проверяйте команду, подставив операцию <span class="command char-style-override-1">-print</span> вместо <span class="command char-style-override-1">-</span><span class="command char-style-override-1">delete</span>, чтобы убедиться, что она не удалит ничего лишнего.</p>

    <p xml:lang="ru-RU">Прежде чем продолжить, давайте посмотрим, как логические операторы воздействуют на операции. Взгляните на следующую команду:</p>

    <p class="list-one"><strong>find ~ -type f -name '*.BAK' -print</strong></p>

    <p xml:lang="ru-RU">Как видите, эта команда ищет обычные файлы (<span class="command char-style-override-1">-type f</span>) с расширением <em>.BAK</em> (<span class="command char-style-override-1">-nam</span><span class="command char-style-override-1">e '*.</span><span class="command char-style-override-1">BAK'</span>) и выводит относительные пути к ним в стандартный вывод (<span class="command char-style-override-1">-</span><span class="command char-style-override-1">print</span>). Однако такой порядок работы команды определяется логическими отношениями между всеми проверками и операциями. Как вы помните, между проверками и операциями по умолчанию подразумевается отношение <span class="command char-style-override-1">-and</span>. Ту же коман­ду можно&#160;&#160;выразить, добавив логические операторы:</p>

    <p class="list-one"><strong>find ~ -type f -and -name '*.BAK' -and -print</strong><strong></strong></p>

    <p xml:lang="ru-RU">Теперь, имея перед глазами это определение, взгляните на табл. 17.7, где показано, как логические операторы влияют на порядок выполнения.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.7.</strong> Влияние логических операторов</p>

    <table id="table-76" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Проверка/операция</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Выполняется, когда...</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-print</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-type f and -name '*.BAK'</span> истинно</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-name '*.BAK'</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-type f </span>истинно</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-type f</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Всегда выполняется, потому что это первая проверка/операция в отношении <span class="command char-style-override-4">-and</span></p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">Так как логические отношения между проверками и операциями определяют необходимость их выполнения, можно сделать вывод, что их порядок следования играет важную роль. Например, если изменить порядок выполнения операций и проверок, поставив операцию <span class="command char-style-override-1">-print</span> на первое место, команда будет вести себя иначе:</p>

    <p class="list-one"><strong>find ~ -print -and -type f -and -name '*.BAK'</strong></p>

    <p xml:lang="ru-RU">Эта версия команды выведет каждый файл (операция <span class="command char-style-override-1">-print</span> всегда возвращает истинное значение), а затем проверит тип файла и его расширение.</p>

    <h4 xml:lang="ru-RU">Операции, определяемые пользователем</h4>

    <p class="Normal0" xml:lang="ru-RU">Помимо предопределенных операций можно также вызывать произвольные ­команды. Традиционно с этой целью используется операция <span class="command char-style-override-1">-exec</span>, что показано ниже:</p>

    <p class="list-one">-exec <em>команда</em> {} ;</p>

    <p xml:lang="ru-RU">где <span class="command char-style-override-1">команда</span> — это имя команды, <span class="command char-style-override-1">{}</span> — символическое представление текущего пути к файлу и точка с запятой — обязательный разделитель, обозначающий конец коман­ды. Следующий пример демонстрирует использование <span class="command char-style-override-1">-exec</span> для получения эффекта, аналогичного операции <span class="command char-style-override-1">-delete</span>, обсуждавшейся выше:</p>

    <p class="list-one">-exec rm '{}' ';'</p>

    <p xml:lang="ru-RU">И снова, поскольку фигурные скобки и точка с запятой имеют специальное значение для командной оболочки, они должны заключаться в кавычки или экранироваться.</p>

    <p xml:lang="ru-RU">Кроме того, существует возможность выполнять пользовательские операции интерактивно. Если заменить операцию <span class="command char-style-override-1">-exec</span> операцией <span class="command char-style-override-1">-ok</span>, перед выполнением каждой указанной команды будет выводиться запрос:</p>

    <p class="list-first"><strong>find ~ -type f -name 'foo*' -ok ls -l '{}' ';'</strong></p>

    <p class="listing-body">&lt; ls ... /home/me/bin/foo &gt; ? <strong>y</strong></p>

    <p class="listing-body">-rwxr-xr-x 1 me&#160;&#160;&#160;me 224 2011-10-29 18:44 /home/me/bin/foo</p>

    <p class="listing-body">&lt; ls ... /home/me/foo.txt &gt; ? <strong>y</strong></p>

    <p class="list-last">-rw-r--r-- 1 me&#160;&#160;&#160;me&#160;&#160;&#160;0 2012-09-19 12:53 /home/me/foo.txt</p>

    <p xml:lang="ru-RU">Эта команда ищет файлы с именами, начинающимися со строки <span class="command char-style-override-1">foo</span>, и для каждого найденного файла выполняет команду <span class="command char-style-override-1">ls -l</span>. Операция <span class="command char-style-override-1">-ok</span> запрашивает подтверждение у пользователя, прежде чем выполнить команду <span class="command char-style-override-1">ls</span>.</p>

    <h4 xml:lang="ru-RU">Увеличение эффективности</h4>

    <p class="Normal0" xml:lang="ru-RU">Каждый раз, когда обнаруживается файл, соответствующий критериям, операция <span class="command char-style-override-1">-exec</span> запускает новый экземпляр указанной команды. Но иногда желательно объединить все результаты поиска и запустить единственный экземпляр команды. Например, вместо последовательности команд, такой как:</p>

    <p class="list-first">ls -l <em>файл1</em></p>

    <p class="list-last">ls -l <em>файл2</em></p>

    <p xml:lang="ru-RU">предпочтительнее было бы выполнить команду:</p>

    <p class="list-one">ls -l <em>файл1</em> <em>файл2</em></p>

    <p xml:lang="ru-RU">Здесь команда выполняется только один раз, а не несколько. Существует два способа добиться этого: традиционный, с использованием внешней команды <span class="command char-style-override-1">xargs</span>, и альтернативный, с использованием новой возможности в самой команде <span class="command char-style-override-1">find</span>. Обсудим сначала альтернативный способ.</p>

    <p xml:lang="ru-RU">Если заменить завершающий символ точки с запятой знаком «плюс», в команде <span class="command char-style-override-1">find</span> активируется функция объединения результатов в список аргументов для вызова единственного экземпляра требуемой команды. Вернемся к нашему примеру. Команда:</p>

    <p class="list-first"><strong>find ~ -type f -name 'foo*' -exec ls -l '{}' ';'</strong></p>

    <p class="listing-body">-rwxr-xr-x 1 me&#160;&#160;&#160;me 224 2011-10-29 18:44 /home/me/bin/foo</p>

    <p class="list-last">-rw-r--r-- 1 me&#160;&#160;&#160;me&#160;&#160;&#160;0 2012-09-19 12:53 /home/me/foo.txt</p>

    <p xml:lang="ru-RU">будет вызывать <span class="command char-style-override-1">ls</span> для каждого найденного файла. Изменив команду, как показано ниже:</p>

    <p class="list-first"><strong>find ~ -type f -name 'foo*' -exec ls -l '{}' +</strong></p>

    <p class="listing-body">-rwxr-xr-x 1 me&#160;&#160;&#160;me 224 2011-10-29 18:44 /home/me/bin/foo</p>

    <p class="list-last">-rw-r--r-- 1 me&#160;&#160;&#160;me&#160;&#160;&#160;0 2012-09-19 12:53 /home/me/foo.txt</p>

    <p xml:lang="ru-RU">мы получим тот же результат, но система выполнит команду <span class="command char-style-override-1">ls</span> только один раз.</p>

    <p xml:lang="ru-RU">Тот же результат можно получить с помощью команды <span class="command char-style-override-1">xargs</span>. Она принимает входные данные со стандартного ввода и преобразует их в список аргументов для указанной команды. В данном примере ее можно было бы использовать так:</p>

    <p class="list-first"><strong>find ~ -type f -name 'foo*' -print | xargs ls -l</strong></p>

    <p class="listing-body">-rwxr-xr-x 1 me&#160;&#160;&#160;me 224 2011-10-29 18:44 /home/me/bin/foo</p>

    <p class="list-last">-rw-r--r-- 1 me&#160;&#160;&#160;me&#160;&#160;&#160;0 2012-09-19 12:53 /home/me/foo.txt</p>

    <p xml:lang="ru-RU">Здесь вывод команды <span class="command char-style-override-1">find</span> передается по конвейеру команде <span class="command char-style-override-1">xargs</span>, которая, в свою очередь, конструирует список аргументов для команды <span class="command char-style-override-1">ls</span> и выполняет ее.</p>

    <p class="Vrezka-head" xml:lang="ru-RU">ПРИМЕЧАНИЕ</p>

    <p class="Vrezka-body" xml:lang="ru-RU">Несмотря на то что в командную строку можно включить большое число аргументов, оно не бесконечно. Не исключена возможность конструирования такой команды, которая окажется слишком велика для командной оболочки. Когда длина командной строки превышает максимально допустимый размер, <span class="command char-style-override-1">xargs</span> выполнит указанную команду с максимально возможным числом аргументов и затем повторит процесс, пока не исчерпает все, что получит со стандартного ввода. Чтобы увидеть максимально возможную длину командной строки, выполните <span class="command char-style-override-1">xargs</span> с параметром <span class="command char-style-override-1">--show-limits</span>.</p>

    <p class="Vrezka-head" xml:lang="ru-RU">обработка файлов с необычными именами</p>

    <p class="Vrezka-body" xml:lang="ru-RU">Unix-подобные системы позволяют встраивать в имена файлов пробелы (и даже символы перевода строки). Это порождает проблемы при выполнении программ, таких как <span class="command char-style-override-1">xargs</span>, конструирующих списки аргументов для других программ. Внутренние пробелы интерпретируются как разделители, и получившаяся команда будет интерпретировать слова, разделенные пробелами, как отдельные аргументы. Для решения этой проблемы <span class="command char-style-override-1">find</span> и <span class="command char-style-override-1">xarg</span> предлагают использовать в качестве разделителя аргументов <em>пустой символ</em> (null character). В кодировке ASCII пустой символ определен как символ с нулевым кодом (в противоположность пробелу, например, который в кодировке ASCII определен как символ с кодом 32). Команда <span class="command char-style-override-1">find</span> поддерживает операцию <span class="command char-style-override-1">-print0</span>, которая производит вывод имен файлов, разделенных пустым символом, а команда <span class="command char-style-override-1">xargs</span> имеет параметр <span class="command char-style-override-1">--null</span>, позволяющий организовать прием значений, разделенных пустым символом. Например:</p>

    <p class="vrezka-listing"><span class="command char-style-override-7">find ~ -iname '*.jpg' -print0 | xargs --null ls -l</span></p>

    <p class="Vrezka-body" xml:lang="ru-RU">Этот прием гарантирует правильную обработку любых имен файлов, даже содержащих пробелы.</p>

    <h3 xml:lang="ru-RU">Возвращаемся в песочницу</h3>

    <p class="Normal0" xml:lang="ru-RU">Пришло время применить <span class="command char-style-override-1">find</span> для решения некоторых практических (почти) задач. Сначала создадим песочницу с множеством файлов и каталогов:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>mkdir -p playground/dir-{00{1..9},0{10..99},100}</strong></p>

    <p class="list-last">[me@linuxbox ~]$ <strong>touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z}</strong></p>

    <p xml:lang="ru-RU">Какая мощь командной строки! Эти две строки создают каталог <span class="command char-style-override-1">playground</span>, содержащий 100 подкаталогов и 26 пустых файлов в каждом. Попробуйте-ка то же самое сделать в графическом интерфейсе!</p>

    <p xml:lang="ru-RU">Это волшебство мы сотворили с помощью уже знакомой команды (<span class="command char-style-override-1">mkdir</span>) механизма подстановки в командной оболочке (фигурные скобки) и новой команды <span class="command char-style-override-1">touch</span>. Объединив команду <span class="command char-style-override-1">mkdir</span> с параметром <span class="command char-style-override-1">-p</span> (который вынуждает <span class="command char-style-override-1">mkdir</span> создать родительские каталоги в указанном пути) с подстановкой фигурных скобок, мы смогли создать 100 каталогов.</p>

    <p xml:lang="ru-RU">Команда <span class="command char-style-override-1">touch</span> обычно используется для обновления времени последнего изменения файлов. Но если передать ей имя несуществующего файла, она создаст пустой файл.</p>

    <p xml:lang="ru-RU">В нашей песочнице мы создали 100 файлов с именем <em>file-A</em>. Давайте найдем их:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -type f -name 'file-A'</strong></p>

    <p xml:lang="ru-RU">Обратите внимание, что, в отличие от <span class="command char-style-override-1">ls</span>, <span class="command char-style-override-1">find</span> возвращает результаты в несортированном порядке. Порядок определяется организацией устройства хранения. Мы можем убедиться, что действительно имеем 100 файлов с именем <em>file-A</em>:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find playground -type f -name 'file-A' | wc -l</strong></p>

    <p class="list-last">100</p>

    <p xml:lang="ru-RU">А теперь выполним поиск файлов по времени их последнего изменения. Этот подход можно использовать для создания резервных копий или организации файлов в хронологическом порядке. Для этого сначала создадим эталонный файл, время последнего изменения которого будет использоваться для сравнения:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>touch playground/timestamp</strong></p>

    <p xml:lang="ru-RU">Эта команда создаст пустой файл <em>timestamp</em> и установит время его последнего изменения равным текущему времени. Мы можем убедиться в этом, использовав еще одну полезную команду, <span class="command char-style-override-1">stat</span>, которую можно рассматривать как своего рода форсированную версию <span class="command char-style-override-1">ls</span>. Команда <span class="command char-style-override-1">stat</span> выводит всю информацию о файле и его атрибутах, которой обладает система:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>stat playground/timestamp</strong></p>

    <p class="listing-body">&#160;&#160;File: `playground/timestamp'</p>

    <p class="listing-body">&#160;&#160;Size: 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Blocks: 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;IO Block: 4096 regular empty file</p>

    <p class="listing-body">Device: 803h/2051d Inode: 14265061 Links: 1</p>

    <p class="listing-body">Access: (0644/-rw-r--r--)&#160;&#160;Uid: ( 1001/ me)&#160;&#160;&#160;Gid: ( 1001/ me)</p>

    <p class="listing-body">Access: 2012-10-08 15:15:39.000000000 -0400</p>

    <p class="listing-body">Modify: 2012-10-08 15:15:39.000000000 -0400</p>

    <p class="list-last">Change: 2012-10-08 15:15:39.000000000 -0400</p>

    <p xml:lang="ru-RU">Если применить команду <span class="command char-style-override-1">touch</span> к файлу еще раз и затем исследовать его с помощью <span class="command char-style-override-1">stat</span>, мы увидим, что время последнего его изменения обновилось:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>touch playground/timestamp</strong></p>

    <p class="listing-body">[me@linuxbox ~]$ <strong>stat playground/timestamp</strong></p>

    <p class="listing-body">&#160;&#160;File: `playground/timestamp'</p>

    <p class="listing-body">&#160;&#160;Size: 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Blocks: 0&#160;&#160;&#160;&#160;&#160;&#160;&#160;IO Block: 4096 regular empty file</p>

    <p class="listing-body">Device: 803h/2051d Inode: 14265061 Links: 1</p>

    <p class="listing-body">Access: (0644/-rw-r--r--)&#160;&#160;Uid: ( 1001/ me)&#160;&#160;&#160;Gid: ( 1001/ me)</p>

    <p class="listing-body">Access: 2012-10-08 15:23:33.000000000 -0400</p>

    <p class="listing-body">Modify: 2012-10-08 15:23:33.000000000 -0400</p>

    <p class="list-last">Change: 2012-10-08 15:23:33.000000000 -0400</p>

    <p xml:lang="ru-RU">Далее воспользуемся командой <span class="command char-style-override-1">find</span>, чтобы обновить время последнего изменения некоторых файлов в нашей песочнице:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -type f -name 'file-B' -exec touch '{}' ';'</strong></p>

    <p xml:lang="ru-RU">Эта команда обновит время последнего изменения для всех файлов с именем <em>file-B</em>, имеющихся в песочнице. Теперь найдем с помощью <span class="command char-style-override-1">find</span> обновленные файлы, сравнив все файлы с эталонным файлом <em>timestamp</em>:</p>

    <p class="list-one">[me@linuxbox ~]$ <strong>find playground -type f -newer playground/timestamp</strong></p>

    <p xml:lang="ru-RU">В результате мы получим все 100 файлов с именем <em>file-B</em>. Поскольку команда <span class="command char-style-override-1">touch</span> применялась ко всем файлм <em>file</em><em>-B</em> в песочнице после обновления файла <em>timestamp</em>, они оказались «новее», чем <em>timestamp</em>, и потому были идентифицированы проверкой <span class="command char-style-override-1">-newer</span>.</p>

    <p xml:lang="ru-RU">В заключение вернемся к проверке плохих разрешений, выполнявшейся выше, и применим ее к каталогу <em>playground</em>:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find playground \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)</strong></p>

    <p class="list-last">199</p>

    <p xml:lang="ru-RU">Эта команда выведет все 100 каталогов и 2600 файлов, хранящихся в <em>playground</em> (а также файл <em>timestamp</em> и сам каталог <em>playground</em>, всего 2702 элемента), потому что ни один из них не соответствует нашему определению «удовлетворительные разрешения». Вооружившись новыми знаниями об операторах и операциях, добавим в эту команду операции для применения новых разрешений к файлам и каталогам в песочнице:</p>

    <p class="list-first">[me@linuxbox ~]$ <strong>find playground \( -type f -not -perm 0600 -exec chmod 0600</strong></p>

    <p class="list-last"><strong>'{}' ';' \) -or \( -type d -not -perm 0700 -exec chmod 0700 '{}' ';' \)</strong></p>

    <p xml:lang="ru-RU">Основываясь на повседневном опыте, следует отметить, что намного проще ввести две команды — одну для каталогов и одну для файлов, чем одну большую составную команду, но знание, что можно действовать именно так, вам не помешает. Главное, что вы должны понять, — как можно использовать операторы и операции для решения практических задач.</p>

    <h3 xml:lang="ru-RU">Параметры</h3>

    <p class="Normal0" xml:lang="ru-RU">Наконец мы добрались до параметров. Параметры помогают управлять областью поиска. Они могут включаться в выражения команды <span class="command char-style-override-1">find</span> наряду с другими проверками и операциями. В табл. 17.8 перечислены наиболее часто используемые параметры.</p>

    <p class="Tabl-head" xml:lang="ru-RU"><strong>Таблица 17.8.</strong> Параметры команды find</p>

    <table id="table-77" class="Table-Style-1">
      <colgroup>      <col/>

      <col/>

</colgroup>

      <tbody>      <tr>      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Параметр</p>

</td>

      <td class="Cell-Style-2">       <p class="Tabl-head" xml:lang="ru-RU">Описание</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-depth</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Требует от <span class="command char-style-override-4">find</span> обработать сначала файлы в каталогах и только потом каталоги. Этот параметр автоматически применяется с операцией <span class="command char-style-override-4">-delete</span></p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-maxdepth число_уровней</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Устанавливает максимальное число уровней, на которое команда <span class="command char-style-override-4">find</span> может опускаться в дереве каталогов, выполняя проверки и операции</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-mindepth число_уровней</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Устанавливает минимальное число уровней, на которое команда <span class="command char-style-override-4">find</span> должна опуститься в дереве каталогов перед выполнением проверок и операций</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-mount</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Требует от <span class="command char-style-override-4">find</span> не выполнять обход каталогов, в которые смонтированы другие файловые системы</p>

</td>

</tr>

      <tr>      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU"><span class="command char-style-override-4">-noleaf</span></p>

</td>

      <td class="Cell-Style-1">       <p class="Tabl-body" xml:lang="ru-RU">Требует от <span class="command char-style-override-4">find</span> не оптимизировать поиск, опираясь на предположение, что поиск ведется в Unix-подобной файловой системе. Этот параметр необходимо использовать при обходе файловых систем DOS/Windows CD-ROM</p>

</td>

</tr>

</tbody>
    </table>

    <p class="No-Paragraph-Style"></p>

    <p xml:lang="ru-RU">&#160;</p>
  </div>
</body>
</html>